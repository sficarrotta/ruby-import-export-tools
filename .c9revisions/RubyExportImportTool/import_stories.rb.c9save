{"ts":1378814500256,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"require 'rally_rest_api'\r\nrequire 'time'\r\nrequire 'stuff'\r\nrequire 'import_scheduleable'\r\n\r\nclass ImportStories < ImportScheduleable\r\n\r\n  @count = 0\r\n  @story = nil\r\n  \r\n  def ImportStories.add_tasks( stuff, story )\r\n      \r\n      task = { :workspace => stuff.workspace,\r\n               :project => stuff.project,\r\n               :name => \"My awesome task!\",\r\n               :state => \"Defined\",\r\n               :estimate => 9.0,\r\n               :work_product => story\r\n      }\r\n      \r\n      rally_task = stuff.slm.create(:task, task)\r\n      \r\n      print \"Created Task : #{rally_task.formatted_i_d}\\n\"\r\n\r\n  end\r\n\r\n  def ImportStories.create_story(stuff, fields)\r\n  \treturn stuff.slm.create(:hierarchical_requirement, fields)\r\n  end\r\n  \r\n  def ImportStories.validate_story(row)\r\n    if (row['TaskEstimate'] != \"\" and row['TaskEstimate'] != nil)\r\n      puts \"WARNING: Ignoring TaskEstimate on Story #{row['Name']}\"\r\n    end\r\n    \r\n    if (row['TaskToDo'] != \"\" and row['TaskToDo'] != nil)\r\n      puts \"WARNING: Ignoring TaskToDo on Story #{row['Name']}\"\r\n    end\r\n    \r\n    if (row['TaskActual'] != \"\" and row['TaskActual'] != nil)\r\n      puts \"WARNING: Ignoring TaskActual on Story #{row['Name']}\"\r\n    end\r\n  end\r\n \r\n  #TODO Make this the same as the create but if the story exists, update it\r\n  def ImportStories.update_story(stuff, header,row)\r\n    name = row['Name']\r\n    state = row['Status']\r\n    description = row['Description']\r\n    owner = row['Owner']\r\n    blocked = row['Blocked']\r\n    release_name = row['Release']\r\n    iteration_name = row['Iteration']\r\n    notes = row['Notes']\r\n#   puts gather_custom_fieldsfields\r\n    \r\n#          :parent => find_parent(stuff, row['Parent']),\r\n    if (row['Parent'] != nil)    \r\n    \tparent = find_parent(stuff, row['Parent'])\r\n    \tif (parent == nil)\r\n    \t\tputs \"Unable to find parent story '#{row['Parent']}'\"\r\n    \tend\r\n    end\r\n    \r\n    print \"Updating: \", name, \"\\n\"\r\n  \r\n    story = nil\r\n    if ( name != \"\" and name != nil)\r\n      query_result = stuff.slm.find(:hierarchical_requirement, :project => stuff.project, :project_scope_up => true, :project_scope_down => true) { equal :name, name }\r\n      story = query_result.results.first\r\n  \r\n      fields = {\r\n        :project => stuff.project\r\n      }\r\n\r\n      # update parent\r\n      if ( parent != nil)\r\n        fields[:parent] = parent\r\n      end\r\n  \r\n      if ( story != nil )  \r\n        if ( state != nil )\r\n          fields[:schedule_state] = state\r\n        end\r\n        \r\n        if ( description != nil )\r\n          fields[:description] = description\r\n        end\r\n        \r\n        if ( owner != nil )\r\n          fields[:owner] = owner\r\n        end\r\n        \r\n        if ( blocked != nil )\r\n          fields[:blocked] = blocked\r\n        end\r\n        \r\n        if ( release_name != nil )\r\n          release = find_release(stuff, release_name)\r\n          if ( release != nil )\r\n            fields[:release] = release\r\n          end\r\n        end\r\n  \r\n        if ( iteration_name != nil )\r\n          iteration = find_iteration(stuff, iteration_name)\r\n          if ( iteration != nil )\r\n            fields[:iteration] = iteration\r\n          end\r\n        end         \r\n        fields.merge!(gather_custom_fields(header, row))\r\n        story.update(fields)\r\n      end\r\n    end\r\n     \r\n  end\r\n    \r\n  def ImportStories.parse_story(stuff, header, row)\r\n    @count = @count + 1\r\n    validate_story(row)\r\n    \r\n    fields = {\r\n      :parent => find_parent(stuff, row['Parent']),\r\n    }\r\n\r\n    fields.merge!(gather_artifact_fields(stuff, header, row))\r\n    fields.merge!(gather_scheduleable_fields(stuff, header, row))\r\n    fields.merge!(gather_custom_fields(header, row))\r\n\r\n    print \"Story: \", row['Name'], \"\\n\"\r\n    story = create_story(stuff, fields)\r\n    print \"Created story #{story.formatted_i_d}\\n\"\r\n    \r\n    update_tags(stuff,story,row[\"Tags\"])\r\n    return story\r\n\r\n  end\r\n  \r\n  def ImportStories.parse_story_row(stuff, header, row)\r\n    if (row['Type'] == \"Story\")\r\n      @story = parse_story(stuff, header, row)\r\n      add_tasks(stuff, @story)\r\n    end\r\n    \r\n    if (row['Type'] == \"UpdateStory\") \r\n      update_story(stuff, header, row)\r\n      updatestoryname = row['Name']\r\n      updatestoryname.gsub(/^\\s+/, \"\").gsub(/\\s+$/, $/)\r\n      # requery for the story so that we can pass it into the parse_task method.\r\n      # this allows us to add tasks as part of an UpdateStory operation.\r\n        query_result = stuff.slm.find(:hierarchical_requirement, :project => stuff.project, :project_scope_up => true, :project_scope_down => true) { equal :name, updatestoryname }\r\n       @story = query_result.results.first\r\n       if @story == nil\r\n       \tputs \"Unable to find story \", row['Name']\r\n       end\r\n              \r\n    end\r\n    \r\n    if (row['Type'] == \"Task\")\r\n      parse_task(stuff, @story, header, row)\r\n    end\r\n  \r\n  end\r\n  \r\n  \r\n  def ImportStories.create_stories(stuff, filename)\r\n    input = FasterCSV.read(filename)\r\n    header = input.first #header row\r\n    \r\n    rows = []\r\n    (1...input.size).each { |i| rows << FasterCSV::Row.new(header, input[i]) }\r\n    \r\n    rows.each { |row| parse_story_row(stuff, header, row)}\r\n  \r\n    print \"Created \", @count, \" Stories\"\r\n  end\r\n\r\nend"]],"start1":0,"start2":0,"length1":0,"length2":5213}]],"length":5213}
